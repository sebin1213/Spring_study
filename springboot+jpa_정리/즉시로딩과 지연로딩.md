> 👍참고
>
> https://ict-nroo.tistory.com/132        즉시로딩 지연로딩
>
> https://incheol-jung.gitbook.io/docs/q-and-a/spring/n+1      n+1
>
> 여기가 훨씬 훌륭하게 설명되어 있습니다.
>
> 
>
> 현재 게시물은 기록용입니다.



**즉시로딩**

연관관계에 있는 애들을 한번에 모두 로딩하겠다는 의미

![image-20211210012620785](C:\Users\1213h\AppData\Roaming\Typora\typora-user-images\image-20211210012620785.png)

즉시로딩( EAGER )은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다. 특히 JPQL을 실행할 때 [N+1문제](####N+1문제)가 자주 발생합니다.

>왜 어떤 SQL이 실행될지 추적이 어렵냐면 예를 들어 Member 를 조회한다고 가정했을때 즉시로딩을 사용하면 연관된 order또한 한번에 조회하게됩니다. 그리고 이 order를 조회할때 연관되어있는 것을 모두 조회하며 줄줄히 조회하게 되는 문제가 발생합니다.



```java
# 즉시로딩
@ManyToOne(fetch = FetchType.EAGER)

# 지연로딩
@ManyToOne(fetch = FetchType.LAZY)
```

em.find()는 PK를 정해놓고 DB에서 가져오기 때문에 JPA 내부에서 최적화를 할 수 있습니다.

하지만 실무에서 자주 사용하는 JPQL일 경우에는  `JPQL : select o from order o; `  ➡ `SQL : select * from order;` 이런식으로 번역이 되버리는 문제가 발생합니다. 이렇게 된다면 조회 결과가 백개일때 백개의 조회 쿼리가 발생하는 [N+1문제](####N+1문제)가 발생합니다.



때문에 **실무에서 모든 연관관계는 지연로딩( LAZY )으로 설정**해야 합니다. 

JPA는 연관된 엔티티를 함께 DB에서 조회해야하는 경우가 발생하면, fetch join 또는 엔티티 그래프 기능을 사용해 해당 정보를 가져옵니다.

> @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야 합니다.
>
> OneToMany는 기본이 LAZY입니다.





#### N+1문제

엔티티를 조회하고 가져온 조회된 데이터 개수가 N개일때 이 N개만큼의 연관관계 조회 쿼리가 발생하는 문제이다. 

`엔티티를 조회하는 쿼리 (1) + N개만큼의 연관관계 조회 쿼리 (N)`











잡담

지연로딩이 가끔 트렌젝션밖에서 안되는 이슈가 가끔있는데 트렉젝션을 빨리가져온다던가 OSIV방식을 쓰는 해결방법이 있다고 합니다. (현재 이부분은 아직 이해 못했습니다. 추후 공부예정)

