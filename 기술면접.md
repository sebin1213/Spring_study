https://junjangsee.github.io/2019/05/15/interview/interview/



### 오버로딩

같은 이름의 함수(메서드)를 여러개 정의하고, 매개변수의 유형과 개수를 다르게 하여 다양한 유형의 호출에 응답할 수 있게됩니다.



### 오버라이딩

상위 클래스가 가지고 있는 메서드도 하위 클래스로 상속되어 하위 클래스에 사용할 수 있습니다. 또한, 하위 클래스에서 메서드를 **재정의**해서도 사용할 수 있습니다.





### 인터페이스와 추상 클래스

**인터페이스와 추상클래스의 공통점**

 \- 추상클래스와 인터페이스는 선언만 있고 구현 내용이 없다.

 \- 그래서 자기 자신이 new를 통해 객체를 생성할 수 없으며, 상속받은 자식만이 객체를 생성할 수 있다.

 \- 상속받은 자식이 구현을 반드시 하도록 해야할 때 사용한다.

 \- JAVA에서는 type이 지정되있기 때문에 선언된 type과 자식의 type이 같아야만 한다.



| **인터페이스(Interface)**             | **추상클래스(Abstract Class)**                         |
| ------------------------------------- | ------------------------------------------------------ |
| 구현 객체의 같은 동작을 보장하기 위함 | 추상클래스를 상속받아 기능을 이용하고, 확장시키기 위함 |
| 다중 상속 가능                        | 다중 상속 불가능                                       |
| 추상메서드만 가능                     | 일반메서드+추상메서드 가능                             |
| 상수+추상메서드 형태                  | 일반변수(가능)+일반메서드(가능)+추상메서드 형태        |
| 생성자와 일반변수를 가질 수 없음      | 생성자와 일반변수 모두 가질 수 있음                    |
| implments                             | extends                                                |
| 메서드 선언만 가능                    | 메서드의 부분적인 구현이 가능                          |





### 인터페이스를 사용하는 이유는 무엇인가?

추상클래스와 비슷한 기능을 하지만 극단적인 경우이다.

 \- 추상메서드와 상수로만 이루어져 있다.(=로직을 작성할 수 없음)

 \- 다중 상속이 가능하다.

설계도라고 생각하면 된다. 하나의 규약, 즉 구체적인 약속 같은 것으로 인해 협업에 필수적이라고 볼 수 있다.



### 추상 클래스를 사용하는 이유는 무엇인가?

상속을 강제하기 위함이다.

부모 클래스에서 정의만 해놓고, 실제 동작은 자식 클래스에서 하게 된다.



### String vs StringBuffer vs StringBuilder

- String
  - immutable(불변)
  - 객체를 한 번 할당할시 **메모리 공간에 변동이 없습니다**.(할당시 Heap String Pool영역에 생성되어 그 값을 계속 사용합니다.)
  - 동기화를 신경쓰지 않아도 됩니다.
  - 엄청나게 많은 문자열을 선언 및 연산할 시 성능저하를 고려해야합니다.
- StringBuffer
  - mutable(가변)
  - 각 메서드별로 Synchronized Keyword가 존재합니다.
  - 멀티스레드 환경에서도 **동기화를 지원**합니다.**(thread-safe)**
- StringBuilder
  - mutable(가변)
  - 동기화를 지원하지 **않습니다**.



> `synchronized` 키워드는 멀티 쓰레드 환경에서 두개 이상의 쓰레드가 하나의 변수에 동시에 접근을 할 때 Race condition(경쟁상태)이 발생하지 않도록 합니다. 
>
> 동기화는 여러 개의 쓰레드가 하나의 자원에 접근하려 할 때 주어진 순간에는 단 `하나의 쓰레드`만이 접근 가능하도록 하는 것입니다.



### HashMap vs HashTable vs ConcurrentHashMap

- HashMap
  - 주요 메서드에 **synchronized 키워드**가 **없습니다**
  - key, value에 null을 입력할 수 **있습니다**.
- HashTable
  - 주요 메서드에 **synchronized 키워드**가 선언 되어 **있습니다**.
  - key, value에 null을 **허용하지 않습니다**.
- ConcurrentHashMap
  - **HashMap**을 **thread-safe** 하도록 만든 클래스
  - key, value에 null을 **허용하지 않습니다**.



### 접근 제어자

- public : 어디서든 접근이 가능합니다.
- protected : 동일 패키지 혹은 상속받은 외부 패키지 클래스에서 사용 가능합니다.
- (default) : 동일 패키지 내에서만 접근 가능합니다.
- private : 해당 클래스 내에서만 접근 가능합니다.



### Error 와 Exception

**오류(Error 에러)- 시스템 레벨에서 발생**하며 개발자가 미리 예측하여 처리할 수 없고 프로그램 코드로 처리 할 수 없습니다

**예외(Exception)- 개발자가 구현한 로직에서 발생**하며 "try", "catch" 와같은 예외처리를 이용하여 해결 가능



### 멀티 스레드 & 멀티 프로세스

