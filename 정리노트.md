# 정리노트

아무거나 다 정리









### cascade = CascadeType.ALL 

persist 할때 커넥션 되어있는 것들 모두 자동적으로 persist 된다. 

cascade를 사용할때는 주의가 필요함 만약에 다양한곳에서 사용되는 객체를 cascade한다면 삭제할때도 연쇄삭제되니까.. 다른것이 참조할수 없는 프라이빗오너인경우에 사용해야함 여튼 잘사용해야함





### 도메인 모델 패턴

엔티티에 비즈니스 로직이 있고 이것을 호출하는 방식

무조건 좋다고 할 수 는 없음 문맥에 따라서 사용하는 것 (유지보수하기 편한것으로 변경)

JPASHOP -> Service -> OrderService 참고



### 트랜잭션 스크립트 패턴

엔티티에는 비즈니스 로직이 거의 없고(getter, setter만 있고) 서비스 계층에서 대부분의 비즈니스 로직을 처리하는 것

JPASHOP -> Service -> MemberService 참고



### 페이징

```python
public List<Order> findAll(OrderSearch orderSearch){
    //order와 order와 연관된 member를 조인
    return em.createQuery("select 0 from Order o join o.member m" +
            "where 0.status = :status" +
            "and m.name like :name",Order.class)
            .setParameter("status",orderSearch.getOrderStatus())
            .setParameter("name", orderSearch.getMemberName())
            .setFirstResult(100) 
            .setMaxResults(1000)
            .getResultList();
}
```

setFirstResult 100부터 시작해서

setMaxResults 1000까지 가져온다











# 어노테이션



### @NoArgsConstructor(access = AccessLevel.PROTECTED)

코드를 작성할때 다음 코드를 외부에서 new를 통해 변경하지 못하도록 protected 로 변경해주는 애노테이션

비즈니스로직은 엔티티가 위치한 곳에 작성(도메인 모델 패턴)했는데 누군가 다른곳에서 따로 비즈니스로직을 작성할 경우를 방지하기 위해 사용한다.



### @Slf4j

롬복에서 제공하는 log를 남길수 있도록하는 어노테이션

```python
@Controller
@Slf4j // 로그남기는 롬복 어노테이션
public class HomeController {
    @RequestMapping("/")
    public String home() {
        log.info("home controller");
        return "home";
    }
}
```



### @NotEmpty

```python
@Getter @Setter
public class MemberForm {

    @NotEmpty(message = "회원 이름은 필수 입니다")
    private String name;
    
    private String city;
    private String street;
    private String zipcode;
}
```

이름이 비어있을시 오류 발생



### @PathVariable

 url에서 각 구분자에 들어오는 값을 처리



### @ModelAttribute

```
<form th:object="${form}" method="post">
```

"${form}"이 넘어옴..?



# HTML



thymeleaf

```html
<form role="form" action="/members/new" th:object="${memberForm}" method="post">
    <div class="form-group">
        <label th:for="name">이름</label>
        <input type="text" th:field="*{name}" class="form-control" placeholder="이름을 입력하세요"
               th:class="${#fields.hasErrors('name')}? 'form-control fieldError' : 'form-control'">
        <p th:if="${#fields.hasErrors('name')}"
           th:errors="*{name}">Incorrect date</p>
    </div>
</form>
```

`th:object="${memberForm}"` 해당 폼 안에서는 이 객체를 사용할 것이다.

`th:field="*{name}"`  memberForm을 참고하는 것 memberForm의 name값을 사용한다는 말, 

해당 값을 가져오고 랜더링 될때 id=name, name=name 이렇게 변경되어 id와 name을 설정해줌

getter, setter 접근법을 이용

`action="/members/new"` 에 데이터가 넘어감



`th:class="${#fields.hasErrors('name')}? 'form-control fieldError' : 'form-control'"` 필드에 에러가 있으면 빨간색 껍데기 만들음 그리고 

`th:if="${#fields.hasErrors('name')}` 해당 에러메세지를 여기에 도출함



# 에러메세지



#### Access to DialectResolutionInfo cannot be null when 'hibernate.dialect' not set 에러메세지

- DB 커넥팅이 제대로 되지 않는 경우
- application 파일에서 DB를 로드하지 못한 경우, 혹은 찾지 못한 경우

h2데이터베이스 안켰을때마다 나타난 오류... 기억하자





### org.springframework.http.converter.HttpMessageConversionException: Type definition error: [simple type, class org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor]; 

hibernate에서는 ByteBuddyInterceptor 해당 클래스가 대신 들어감

```
public class Order {

    @Id @GeneratedValue
    @Column(name = "order_id")
    private Long id = new ByteBuddyInterceptor(); // 이렇게 가짜로 넣어놈
```

프록시객체를 가짜로 넣어놓고 객체를 손대거나 했을때 sql을 날려서 객체의 값을 채워줌

json이 id를 뽑을려하는데 id가 아니라 ByteBuddyInterceptor가 와버려서 오류가 발생함

jackson 라이브러리는 기본적으로 이 프록시 객체를 json으로 어떻게 생성해야 하는지 모름 예외 발생
Hibernate5Module 을 스프링 빈으로 등록하면 해결(스프링 부트 사용중)

```
@Bean
Hibernate5Module hibernate5Module() {
    return new Hibernate5Module();
}
```

```
implementation 'com.fasterxml.jackson.datatype:jackson-datatype-hibernate5'
```

