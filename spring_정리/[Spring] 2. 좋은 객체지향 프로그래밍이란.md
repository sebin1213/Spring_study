## 객체 지향 특징



#### 🔴 추상화

- 어떤 영역에서 필요로하는 속성이나 행동을 추출하는 작업
- 불필요한 부분을 생략하고 객체의 속성 중 가장 중요한 것에만 중점을 두어 개략화하는 것

#### 🟠 캡슐화

- 데이터(속성, 필드)와 데이터를 다루는 방법(메서드)을 결합시켜 묶는 것

- 특정 객체가 독립적으로 역할을 제대로 수행하기 위해 필요한 데이터와 기능을 하나로 묶어 관리한다

- 캡슐화된 객체의 세부 구현이

   

  외부에 은폐(정보 은닉)

  되어, 변경이 발생할 때 오류의 파급효과가 적다

  - 세부 구현 (내부적으로 어떠한 자료구조, 어떠한 방식으로 구현했는지를 감춘다)
  - 세부 구현에 독립적으로 제공되는 메서드만 이용하기 때문에 결합도 낮아진다

- 캡슐화는 **정보 은닉**을 통해 높은 응집도와 낮은 결합도를 갖도록 한다

- 캡슐화된 객체들은 재사용이 용이하다

#### 🟡 정보은닉

- 캡슐화에서 가장 중요한 개념으로, 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통해서 접근을 허용하는 것
- 각 객체의 수정이 다른 객체에게 주는 영향을 최소화함 (응집도 높이고, 결합도 낮춤)
- 외부 객체가 특정 객체의 데이터와 함수를 직접 접근하여 사용하거나 변경하지 못하므로 유지보수와 소프트웨어 확장시 오류 최소화

#### 🟢 상속

- 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
- 상속을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스 내에서 다시 정의하지 않고도 즉시 자신의 속성으로 사용 가능
- 하위 클래스는 상위 클래스로부터 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용 가능
- 상위 클래스의 속성과 연산을 하위 클래스가 공유할 수 있기 때문에 객체와 클래스의 재사용, 즉 소프트웨어 재사용을 증대시키는 중요한 개념

#### 🔵 다형성

- 같은 자료형에 여러가지 객체를 대입하여 다양한 결과를 얻어내는 성질
- 하나의 타입으로 다양한 실행 결과를 얻을 수 있으며, 객체를 부품화하여 유지 보수를 용이하게 함
- 여러가지 형태를 가질 수 있는 것
- 하나의 메소드나 클래스가 있을 때, 이것들이 다양한 방법으로 동작하는 것 (대표적으로 오버라이딩있다)
- **하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것 (부모타입 참조변수로 자식 타입 인스턴스 참조 가능, 반대는 불가) : 제일 깔끔한 정의인듯!**

## 객체 지향 프로그래밍

### 정의

> 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시간에서 벗어나 여러 개의 독립된 단위, 즉 **"객체"**들의 **모임**으로 파악하고자 하는 것. 각각의 **객체**는 **메시지**를 주고 받고, 데이터를 처리할 수 있다**(협력)**

> 객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경**이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다

핵심 키워드 : 객체들의 모임, 객체들이 메시지를 주고 받으면서 서로 상호작용한다, 유연하고 변경이 용이



### 유연하고 변경이 용이?

- 레고 블럭 조립하듯이

- 키보드 마우스 갈아 끼우듯이

- 컴퓨터 부품 갈아 끼우듯이

- **✨컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법**

  

## 다형성의 실세계 비유

- 실세계와 객체 지향을 1:1로 매칭X

- 그래도 실세계의 비유로 이해하기에는 좋음

- **역할**과 **구현**으로 세상을 구분

  

### 운전자 자동차 예시

![img](https://media.vlpt.us/images/syleemk/post/e5ec057e-969b-4ea7-bcbc-94245e708bbb/image.png)

- 운전자는 차종이 바뀌는 것과 상관없이 운전이 가능

- 구체적인 구현이 바뀌는 것에 영향받지 않는다

  

**이게 가능한 이유**❗❗

자동차 역할(인터페이스)에 따라서 자동차들을 구현했기 때문!!

운전자는 자동차 인터페이스(역할)만 알고있음
운전자는 자동차 인터페이스에만 의존한다!!

자동차 역할과 구현을 분리한 것은 누구를 위해서??
➡ 운전자를 위해서

클라이언트(운전자)가 자동차의 내부구조(구현)을 몰라도된다
구현이 내부적으로 바뀌더라도 자동차 인터페이스만 따른다면 클라이언트에 영향을 주지 않는다

심지어 완전히 새로운 자동차가 나온다 하더라도, 기존 자동차 인터페이스만 따른다면 사용가능하다!!
➡ 자동차 세상을 무한히 확장 가능

**핵심**

> 새로운 자동차가 나오더라도 클라이언트는 새로운 자동차에 대한 것을 배우지 않아도된다 (클라이언트를 바꿀 필요가 없다!)



### 공연 무대 예시

![img](https://media.vlpt.us/images/syleemk/post/b19f5aca-ee4d-4bdd-ac38-212125e1e5ce/image.png)

로미오 줄리엣 공연에서 로미오 역할과 줄리엣 역할이 존재
각각의 역할을 여러 배우가 할 수 있는 것!

공연시 배우는 **대체가 가능**해야한다!!

**HOW?**

역할과 구현을 나눔! ➡ 변경 가능, 대체 가능성이 생긴다 = 유연하고 변경 용이하다는 뜻

내부 구조를 몰라도 된다

줄리엣 역할의 구현이 바뀐다고 해서 로미오 역할에 영향을 주지 않는다
다른 대상으로 대체가 가능하다 ➡ 유연하고 변경 용이하다



## 역할과 구현을 분리

- **역할**과 **구현**으로 구분하면 세상이 **단순**해지고, **유연**해지며 **변경**도 편리해진다.
- 장점
  - **클라이언트**는 대상의 역할(인터페이스)만 알면된다.
  - **클라이언트**는 구현 대상의 **내부 구조를 몰라도** 된다.
  - **클라이언트**는 구현 대상의 **내부 구조가 변경**되어도 영향을 받지 않는다.
  - **클라이언트**는 구현 **대상 자체를 변경**해도 영향을 받지 않는다. (k3->테슬라)

### 자바 언어

- 자바 언어의 다형성 활용
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 **역할**과 **구현**을 명확히 분리
- 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 객체를 만들기

물론 인터페이스가 아닌 일반 상속관계도 다형성 가능
하지만, 웬만하면 인터페이스 사용
왜냐하면 인터페이스는 다중 상속이 되기 때문.. 일반상속은 단계상속만 가능



## 객체의 협력이라는 관계부터 생각

- 혼자 있는 객체는 없다
- 클라이언트 : **요청**, 서버 : **응답**
- 수 많은 객체 클라이언트와 객체 서버는 서로 협력관계를 가진다

![img](https://media.vlpt.us/images/syleemk/post/c892b833-bc90-4897-87f2-7119370dae5e/image.png)

## 자바 언어의 다형성

- 오버라이딩을 떠올려보자 ( 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하는 것)
- 오버라이딩은 자바 기본 문법
- 오버라이딩 된 매세드가 실행됨
- 다형성으로 인터페이스를 구현한 객체를 실행시점에 유연하게 변경할 수 있다
- 물론 클래스 상속관계도 다형성, 오버라이딩 적용 가능

![img](https://media.vlpt.us/images/syleemk/post/d7eaf0bd-4485-4d56-8c19-55f02fd09091/image.png)

- 클라이언트는 MemberRepository 인터페이스에 의존

- 해당 인터페이스에 구체적인 구현 클래스인 MemoryMemberRepository나 JdbcMemberRepository를 할당 가능

  

## 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 **실행 시점**에 **유연**하게 **변경**할 수 있다. (jdbc, memory, jpa등 한줄만 바꾸면 다른 스프링데이터로 갈아끼울수있음)

- 다형성의 본질을 이해하려면 **협력**이라는 객체사이의 관계에서 시작해야한다

- ✨**클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다**

  

## 정리

- 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있다

- 유연하고 변경이 용이하다

- **확장 가능한 설계**

- 클라이언트에 영향을 주지 않는 변경 가능

- 인터페이스를 안정적으로 잘 설계하는 것이 중요❗❗

  

## 한계

- 역할(인터페이스) 자체가 변하면, 클라이언트 서버 모두에게 큰 변경이 발생한다
  - 자동차를 비행기로 변경해야한다면?
  - 대본 자체가 변경된다면?
  - USB 인터페이스가 변경된다면?
- **인터페이스를 안정적으로 잘 설계하는 것이 중요** (가장 변화가 없도록 설계하는 것이 중요)

앱 혹은 웹 혹은 서버 to 서버 API 설계할때도, API자체를 안정적으로 설계하는 것이 중요!

좀 변화가 있더라도 인터페이스 자체가 안 흔들리도록 설계하는 것이 중요하다.



## 스프링과 객체 지향

- 다형성이 가장 중요하다!
- **스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.**
- **스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.**
- 스프링을 사용하면 마치 레고 블럭 조립하듯이! 공연 무대의 배우를 선택하듯이! 구현을 편리하게 변경할 수 있다.









참고자료
[객체지향 특징1](https://coding-factory.tistory.com/328)
[객체지향 특징2](https://gmlwjd9405.github.io/2018/07/05/oop-features.html)
[다형성](https://mainpower4309.tistory.com/11)